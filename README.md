# Лекции по сетевым операционным системам и их администрированию Корнеев И. КТСО-01-20
---
Оглавление
 * [Lec2_3](https://github.com/uncmars83/Lectures/tree/main/Lec2_3/)

      * [Program1](https://github.com/uncmars83/Lectures/tree/main/Lec2_3/Program1)
      * [Program2](https://github.com/uncmars83/Lectures/tree/main/Lec2_3/Program2)
      * [Program3](https://github.com/uncmars83/Lectures/tree/main/Lec2_3/Program3)

 * [Lec4](https://github.com/uncmars83/Lectures/tree/main/Lec4/)

      * [Program1](https://github.com/uncmars83/Lectures/tree/main/Lec4/Program1)
      * [Program2](https://github.com/uncmars83/Lectures/tree/main/Lec4/Program2)
      * [Program3](https://github.com/uncmars83/Lectures/tree/main/Lec4/Program3)

---

Все представленные программы можно установить и запустить на ОС GNU/Linux.

---

### Лекции 2-3
#### Program1
Пример программы динамического выделения памяти для массива.
Программа запрашивает длину массива. Затем выделяется память с помощью функции malloc. При выделении памяти возвращается указатель, который будет равен NULL, если память не выделилась. Если массив инициализирован, то выделенная память осовобождается.

---

#### Program2
Пример программы системного вызова fork().
В начале вызывается системный вызов fork(). После этого момента программа делится на двое и в результате вызова функции появляется один ребенок. С помощью оператора switch-case мы определяем, каким является процесс - ошибка (case -1:) или ребенок (case 0:), или родитель (default:). Как правило, процесс потомка всегда больше, чем у родителя, а определяется это с помощью функции getpid().

---

#### Program3
Пример программы для чтения данных из файла.
В начале выделяем память для массива чаров с помощью функции calloc. Затем создаем дескриптор и открываем файл для чтения, если файла не будет, то он будет создан. Выводим значение дескриптора файла. После читаем из файла 10 байт и записываем в переменную sz количество байт, которое удалось прочитать. Далее обязательно записываем в конец массива, в который записывали прочитанную информацию, символ конца строки (терминальный ноль). В конце программы закрываем файл.

---

### Лекция 4
#### Program1
Сигналы. Пример работы программы.
В начале работы программы срабатывает системный вызов signal() и привязывает сигнал SIGUSR1 к одному из обработчиков handler1. Далее выполнятеся проверка на то, что мы ребенок и, если мы им оказываеся, то переопределяем обработчик handler1 на handler2. Из ребенка используется системный вызов kill() и отправляется сигнал родителю. handler1 и handler2 - две обрабатывающие функции, которые принимают на вход наш сигнал с целочисленным типом данных.

---

#### Program2
Неименованные каналы. Пример работы программы.
Для работы с неименованными каналами используются два дескриптора. Системный вызов pipe записывает два дескриптора с обработкой ошибок. Далее используется системный вызов fork() для получения дочернего процесса, и обрабатываем ошибки. Если cpid равняется 0, то процесс - потомок. Получается что один дескриптор - для чтения, а второй дескриптор - для записи. То есть сообщение передается между процессами с помощью каналов.

---

#### Program3
Именованные каналы. Пример работы программы.
Создаём дескриптор канала и именованный канал с правами доступа для всех. После запускается цикл прослушивания канала. В момент, когда в этот канал попадает сообщение, то выводится количество символов, включая 0 конца строки, и само сообщение.
